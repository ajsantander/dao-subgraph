// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class NewVersion extends EthereumEvent {
  get params(): NewVersion__Params {
    return new NewVersion__Params(this);
  }
}

export class NewVersion__Params {
  _event: NewVersion;

  constructor(event: NewVersion) {
    this._event = event;
  }

  get versionId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get semanticVersion(): Array<i32> {
    return this._event.parameters[1].value.toI32Array();
  }
}

export class ScriptResult extends EthereumEvent {
  get params(): ScriptResult__Params {
    return new ScriptResult__Params(this);
  }
}

export class ScriptResult__Params {
  _event: ScriptResult;

  constructor(event: ScriptResult) {
    this._event = event;
  }

  get executor(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get script(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get input(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get returnData(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class RecoverToVault extends EthereumEvent {
  get params(): RecoverToVault__Params {
    return new RecoverToVault__Params(this);
  }
}

export class RecoverToVault__Params {
  _event: RecoverToVault;

  constructor(event: RecoverToVault) {
    this._event = event;
  }

  get vault(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Repo__getLatestResult {
  value0: Array<i32>;
  value1: Address;
  value2: Bytes;

  constructor(value0: Array<i32>, value1: Address, value2: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromI32Array(this.value0));
    map.set("value1", EthereumValue.fromAddress(this.value1));
    map.set("value2", EthereumValue.fromBytes(this.value2));
    return map;
  }
}

export class Repo__getLatestForContractAddressResult {
  value0: Array<i32>;
  value1: Address;
  value2: Bytes;

  constructor(value0: Array<i32>, value1: Address, value2: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromI32Array(this.value0));
    map.set("value1", EthereumValue.fromAddress(this.value1));
    map.set("value2", EthereumValue.fromBytes(this.value2));
    return map;
  }
}

export class Repo__getBySemanticVersionResult {
  value0: Array<i32>;
  value1: Address;
  value2: Bytes;

  constructor(value0: Array<i32>, value1: Address, value2: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromI32Array(this.value0));
    map.set("value1", EthereumValue.fromAddress(this.value1));
    map.set("value2", EthereumValue.fromBytes(this.value2));
    return map;
  }
}

export class Repo__getByVersionIdResult {
  value0: Array<i32>;
  value1: Address;
  value2: Bytes;

  constructor(value0: Array<i32>, value1: Address, value2: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromI32Array(this.value0));
    map.set("value1", EthereumValue.fromAddress(this.value1));
    map.set("value2", EthereumValue.fromBytes(this.value2));
    return map;
  }
}

export class Repo extends SmartContract {
  static bind(address: Address): Repo {
    return new Repo("Repo", address);
  }

  hasInitialized(): boolean {
    let result = super.call("hasInitialized", []);

    return result[0].toBoolean();
  }

  try_hasInitialized(): CallResult<boolean> {
    let result = super.tryCall("hasInitialized", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getEVMScriptExecutor(_script: Bytes): Address {
    let result = super.call("getEVMScriptExecutor", [
      EthereumValue.fromBytes(_script)
    ]);

    return result[0].toAddress();
  }

  try_getEVMScriptExecutor(_script: Bytes): CallResult<Address> {
    let result = super.tryCall("getEVMScriptExecutor", [
      EthereumValue.fromBytes(_script)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  getRecoveryVault(): Address {
    let result = super.call("getRecoveryVault", []);

    return result[0].toAddress();
  }

  try_getRecoveryVault(): CallResult<Address> {
    let result = super.tryCall("getRecoveryVault", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  allowRecoverability(token: Address): boolean {
    let result = super.call("allowRecoverability", [
      EthereumValue.fromAddress(token)
    ]);

    return result[0].toBoolean();
  }

  try_allowRecoverability(token: Address): CallResult<boolean> {
    let result = super.tryCall("allowRecoverability", [
      EthereumValue.fromAddress(token)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  appId(): Bytes {
    let result = super.call("appId", []);

    return result[0].toBytes();
  }

  try_appId(): CallResult<Bytes> {
    let result = super.tryCall("appId", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  getInitializationBlock(): BigInt {
    let result = super.call("getInitializationBlock", []);

    return result[0].toBigInt();
  }

  try_getInitializationBlock(): CallResult<BigInt> {
    let result = super.tryCall("getInitializationBlock", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  canPerform(_sender: Address, _role: Bytes, _params: Array<BigInt>): boolean {
    let result = super.call("canPerform", [
      EthereumValue.fromAddress(_sender),
      EthereumValue.fromFixedBytes(_role),
      EthereumValue.fromUnsignedBigIntArray(_params)
    ]);

    return result[0].toBoolean();
  }

  try_canPerform(
    _sender: Address,
    _role: Bytes,
    _params: Array<BigInt>
  ): CallResult<boolean> {
    let result = super.tryCall("canPerform", [
      EthereumValue.fromAddress(_sender),
      EthereumValue.fromFixedBytes(_role),
      EthereumValue.fromUnsignedBigIntArray(_params)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getEVMScriptRegistry(): Address {
    let result = super.call("getEVMScriptRegistry", []);

    return result[0].toAddress();
  }

  try_getEVMScriptRegistry(): CallResult<Address> {
    let result = super.tryCall("getEVMScriptRegistry", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  CREATE_VERSION_ROLE(): Bytes {
    let result = super.call("CREATE_VERSION_ROLE", []);

    return result[0].toBytes();
  }

  try_CREATE_VERSION_ROLE(): CallResult<Bytes> {
    let result = super.tryCall("CREATE_VERSION_ROLE", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBytes());
  }

  kernel(): Address {
    let result = super.call("kernel", []);

    return result[0].toAddress();
  }

  try_kernel(): CallResult<Address> {
    let result = super.tryCall("kernel", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  isPetrified(): boolean {
    let result = super.call("isPetrified", []);

    return result[0].toBoolean();
  }

  try_isPetrified(): CallResult<boolean> {
    let result = super.tryCall("isPetrified", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  getLatest(): Repo__getLatestResult {
    let result = super.call("getLatest", []);

    return new Repo__getLatestResult(
      result[0].toI32Array(),
      result[1].toAddress(),
      result[2].toBytes()
    );
  }

  try_getLatest(): CallResult<Repo__getLatestResult> {
    let result = super.tryCall("getLatest", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new Repo__getLatestResult(
        value[0].toI32Array(),
        value[1].toAddress(),
        value[2].toBytes()
      )
    );
  }

  getLatestForContractAddress(
    _contractAddress: Address
  ): Repo__getLatestForContractAddressResult {
    let result = super.call("getLatestForContractAddress", [
      EthereumValue.fromAddress(_contractAddress)
    ]);

    return new Repo__getLatestForContractAddressResult(
      result[0].toI32Array(),
      result[1].toAddress(),
      result[2].toBytes()
    );
  }

  try_getLatestForContractAddress(
    _contractAddress: Address
  ): CallResult<Repo__getLatestForContractAddressResult> {
    let result = super.tryCall("getLatestForContractAddress", [
      EthereumValue.fromAddress(_contractAddress)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new Repo__getLatestForContractAddressResult(
        value[0].toI32Array(),
        value[1].toAddress(),
        value[2].toBytes()
      )
    );
  }

  getBySemanticVersion(
    _semanticVersion: Array<i32>
  ): Repo__getBySemanticVersionResult {
    let result = super.call("getBySemanticVersion", [
      EthereumValue.fromI32Array(_semanticVersion)
    ]);

    return new Repo__getBySemanticVersionResult(
      result[0].toI32Array(),
      result[1].toAddress(),
      result[2].toBytes()
    );
  }

  try_getBySemanticVersion(
    _semanticVersion: Array<i32>
  ): CallResult<Repo__getBySemanticVersionResult> {
    let result = super.tryCall("getBySemanticVersion", [
      EthereumValue.fromI32Array(_semanticVersion)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new Repo__getBySemanticVersionResult(
        value[0].toI32Array(),
        value[1].toAddress(),
        value[2].toBytes()
      )
    );
  }

  getByVersionId(_versionId: BigInt): Repo__getByVersionIdResult {
    let result = super.call("getByVersionId", [
      EthereumValue.fromUnsignedBigInt(_versionId)
    ]);

    return new Repo__getByVersionIdResult(
      result[0].toI32Array(),
      result[1].toAddress(),
      result[2].toBytes()
    );
  }

  try_getByVersionId(
    _versionId: BigInt
  ): CallResult<Repo__getByVersionIdResult> {
    let result = super.tryCall("getByVersionId", [
      EthereumValue.fromUnsignedBigInt(_versionId)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new Repo__getByVersionIdResult(
        value[0].toI32Array(),
        value[1].toAddress(),
        value[2].toBytes()
      )
    );
  }

  getVersionsCount(): BigInt {
    let result = super.call("getVersionsCount", []);

    return result[0].toBigInt();
  }

  try_getVersionsCount(): CallResult<BigInt> {
    let result = super.tryCall("getVersionsCount", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  isValidBump(_oldVersion: Array<i32>, _newVersion: Array<i32>): boolean {
    let result = super.call("isValidBump", [
      EthereumValue.fromI32Array(_oldVersion),
      EthereumValue.fromI32Array(_newVersion)
    ]);

    return result[0].toBoolean();
  }

  try_isValidBump(
    _oldVersion: Array<i32>,
    _newVersion: Array<i32>
  ): CallResult<boolean> {
    let result = super.tryCall("isValidBump", [
      EthereumValue.fromI32Array(_oldVersion),
      EthereumValue.fromI32Array(_newVersion)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }
}

export class TransferToVaultCall extends EthereumCall {
  get inputs(): TransferToVaultCall__Inputs {
    return new TransferToVaultCall__Inputs(this);
  }

  get outputs(): TransferToVaultCall__Outputs {
    return new TransferToVaultCall__Outputs(this);
  }
}

export class TransferToVaultCall__Inputs {
  _call: TransferToVaultCall;

  constructor(call: TransferToVaultCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferToVaultCall__Outputs {
  _call: TransferToVaultCall;

  constructor(call: TransferToVaultCall) {
    this._call = call;
  }
}

export class InitializeCall extends EthereumCall {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class NewVersionCall extends EthereumCall {
  get inputs(): NewVersionCall__Inputs {
    return new NewVersionCall__Inputs(this);
  }

  get outputs(): NewVersionCall__Outputs {
    return new NewVersionCall__Outputs(this);
  }
}

export class NewVersionCall__Inputs {
  _call: NewVersionCall;

  constructor(call: NewVersionCall) {
    this._call = call;
  }

  get _newSemanticVersion(): Array<i32> {
    return this._call.inputValues[0].value.toI32Array();
  }

  get _contractAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _contentURI(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class NewVersionCall__Outputs {
  _call: NewVersionCall;

  constructor(call: NewVersionCall) {
    this._call = call;
  }
}
